import type {
  AgentCallResult,
  ExerciseSlot,
  ProfileAnalysis,
  ProgramSkeleton,
  ExerciseAssignment,
  ValidationResult,
  OrchestrationResult,
  CompressedExercise,
  ProgramCategory,
  ProgramDifficulty,
} from "./types.js"
import { callAgent, MODEL_HAIKU, MODEL_SONNET } from "./anthropic.js"
import { scoreAndFilterExercises, semanticFilterExercises } from "./exercise-filter.js"
import { estimateTokens } from "./token-utils.js"
import { profileAnalysisSchema, programSkeletonSchema, exerciseAssignmentSchema } from "./schemas.js"
import { PROFILE_ANALYZER_PROMPT, PROGRAM_ARCHITECT_PROMPT, EXERCISE_SELECTOR_PROMPT } from "./prompts.js"
import { validateProgram } from "./validate.js"
import { filterByDifficultyScore, formatExerciseLibrary } from "./exercise-context.js"
import { getExercisesForAI } from "./program-chat-tools.js"
import { retrieveSimilarContext, formatRagContext, buildRagAugmentedPrompt, embedConversationMessage } from "./rag.js"
import { getSupabase } from "../lib/supabase.js"

const MAX_RETRIES = 2

// ─── Types ──────────────────────────────────────────────────────────────────

export interface AssessmentContext {
  assessmentResultId: string
  computedLevels: { overall: string; squat: string; push: string; pull: string; hinge: string }
  maxDifficultyScore: number
  generationTrigger: "initial_assessment" | "reassessment"
}

export interface AiGenerationRequest {
  client_id?: string | null
  goals: string[]
  duration_weeks: number
  sessions_per_week: number
  session_minutes?: number
  split_type?: string
  periodization?: string
  tier?: string
  additional_instructions?: string
  equipment_override?: string[]
  is_public?: boolean
}

// ─── Helpers ────────────────────────────────────────────────────────────────

function deriveProgramCategory(goals: string[]): ProgramCategory {
  const goalSet = new Set(goals.map((g) => g.toLowerCase()))
  if (goalSet.has("muscle_gain") && goalSet.has("endurance")) return "hybrid"
  if (goalSet.has("muscle_gain") || goalSet.has("weight_loss")) return "strength"
  if (goalSet.has("endurance")) return "conditioning"
  if (goalSet.has("sport_specific")) return "sport_specific"
  if (goalSet.has("flexibility")) return "recovery"
  if (goalSet.has("general_health")) return "hybrid"
  return "strength"
}

function mapDifficulty(experienceLevel: string | null): ProgramDifficulty {
  switch (experienceLevel) {
    case "beginner": return "beginner"
    case "intermediate": return "intermediate"
    case "advanced": return "advanced"
    case "elite": return "elite"
    default: return "beginner"
  }
}

// ─── Supabase helpers ───────────────────────────────────────────────────────

async function getProfileByUserId(userId: string) {
  const supabase = getSupabase()
  const { data } = await supabase.from("client_profiles").select("*").eq("user_id", userId).single()
  return data
}

async function getUserById(userId: string) {
  const supabase = getSupabase()
  const { data } = await supabase.from("users").select("*").eq("id", userId).single()
  if (!data) throw new Error("User not found")
  return data
}

async function createProgram(params: Record<string, unknown>) {
  const supabase = getSupabase()
  const { data, error } = await supabase.from("programs").insert(params).select().single()
  if (error) throw new Error(`Failed to create program: ${error.message}`)
  return data
}

async function addExerciseToProgram(params: Record<string, unknown>) {
  const supabase = getSupabase()
  const { error } = await supabase.from("program_exercises").insert(params)
  if (error) throw new Error(`Failed to add exercise: ${error.message}`)
}

async function createAssignment(params: Record<string, unknown>) {
  const supabase = getSupabase()
  const { error } = await supabase.from("program_assignments").insert(params)
  if (error) throw new Error(`Failed to create assignment: ${error.message}`)
}

async function createGenerationLog(params: Record<string, unknown>) {
  const supabase = getSupabase()
  const { data, error } = await supabase.from("ai_generation_log").insert(params).select().single()
  if (error) throw new Error(`Failed to create generation log: ${error.message}`)
  return data
}

async function updateGenerationLog(id: string, updates: Record<string, unknown>) {
  const supabase = getSupabase()
  await supabase.from("ai_generation_log").update(updates).eq("id", id)
}

async function saveConversationBatch(messages: Array<Record<string, unknown>>) {
  const supabase = getSupabase()
  const cleaned = messages.map((m) => {
    const { embedding: _e, ...rest } = m as Record<string, unknown>
    return rest
  })
  const { data, error } = await supabase.from("ai_conversation_history").insert(cleaned).select()
  if (error) throw new Error(`Failed to save conversation: ${error.message}`)
  return data ?? []
}

// ─── Full Synchronous Pipeline ──────────────────────────────────────────────

export async function generateProgramSync(
  request: AiGenerationRequest,
  requestedBy: string,
  assessmentContext?: AssessmentContext
): Promise<OrchestrationResult> {
  console.log("[orchestrator:sync] Starting generateProgramSync", {
    client_id: request.client_id ?? "none",
    goals: request.goals,
    duration_weeks: request.duration_weeks,
    sessions_per_week: request.sessions_per_week,
  })
  const startTime = Date.now()
  const tokenUsage = { agent1: 0, agent2: 0, agent3: 0, agent4: 0, total: 0 }
  let retries = 0

  const log = await createGenerationLog({
    program_id: null,
    client_id: request.client_id ?? null,
    requested_by: requestedBy,
    status: "generating",
    input_params: request,
    output_summary: null,
    error_message: null,
    model_used: "haiku+sonnet-mixed",
    tokens_used: null,
    duration_ms: null,
    completed_at: null,
    current_step: 0,
    total_steps: 3,
    ...(assessmentContext ? {
      generation_trigger: assessmentContext.generationTrigger,
      assessment_result_id: assessmentContext.assessmentResultId,
    } : {}),
  })
  console.log("[orchestrator:sync] Generation log created:", log.id)

  try {
    // Fetch client profile
    let profile: Awaited<ReturnType<typeof getProfileByUserId>> = null
    let clientName = "General Client"
    if (request.client_id) {
      profile = await getProfileByUserId(request.client_id)
      try {
        const user = await getUserById(request.client_id)
        clientName = `${user.first_name} ${user.last_name}`.trim()
      } catch { clientName = "Client" }
    }

    let age: number | null = null
    if (profile?.date_of_birth) {
      const birthYear = parseInt(profile.date_of_birth, 10)
      if (!isNaN(birthYear)) age = new Date().getFullYear() - birthYear
    }

    const profileContext = profile
      ? JSON.stringify({
          goals: profile.goals, sport: profile.sport, gender: profile.gender, age,
          date_of_birth: profile.date_of_birth, experience_level: profile.experience_level,
          movement_confidence: profile.movement_confidence, sleep_hours: profile.sleep_hours,
          stress_level: profile.stress_level, occupation_activity_level: profile.occupation_activity_level,
          training_years: profile.training_years, injuries: profile.injuries,
          injury_details: profile.injury_details, available_equipment: profile.available_equipment,
          preferred_session_minutes: profile.preferred_session_minutes,
          preferred_training_days: profile.preferred_training_days,
          preferred_day_names: profile.preferred_day_names,
          preferred_techniques: profile.preferred_techniques,
          time_efficiency_preference: profile.time_efficiency_preference,
          height_cm: profile.height_cm, weight_kg: profile.weight_kg,
          exercise_likes: profile.exercise_likes, exercise_dislikes: profile.exercise_dislikes,
          training_background: profile.training_background, additional_notes: profile.additional_notes,
        })
      : JSON.stringify({ note: "No profile found — use defaults for a general fitness client." })

    const assessmentSection = assessmentContext
      ? `\n\n## Client Assessment Results
Overall Level: ${assessmentContext.computedLevels.overall}
Squat Pattern: ${assessmentContext.computedLevels.squat}
Push Pattern: ${assessmentContext.computedLevels.push}
Pull Pattern: ${assessmentContext.computedLevels.pull}
Hinge Pattern: ${assessmentContext.computedLevels.hinge}
Maximum Exercise Difficulty: ${assessmentContext.maxDifficultyScore}/10

IMPORTANT: Only select exercises with difficulty_score <= ${assessmentContext.maxDifficultyScore}.`
      : ""

    const agent1UserMessage = `Client Profile:\n${profileContext}\n\nTraining Request:\n- Goals: ${request.goals.join(", ")}\n- Duration: ${request.duration_weeks} weeks\n- Sessions per week: ${request.sessions_per_week}\n- Session length: ${request.session_minutes ?? 60} minutes\n${request.split_type ? `- Requested split type: ${request.split_type}` : ""}\n${request.periodization ? `- Requested periodization: ${request.periodization}` : ""}\n${request.equipment_override ? `- Equipment override: ${request.equipment_override.join(", ")}` : ""}\n${request.additional_instructions ? `- Additional instructions: ${request.additional_instructions}` : ""}${assessmentSection}`

    // RAG
    const ragQuery = `${request.goals.join(", ")} ${request.duration_weeks}wk ${request.sessions_per_week}x/wk ${profile?.experience_level ?? "beginner"}`
    const ragResults = await retrieveSimilarContext(ragQuery, "program_generation", { threshold: 0.5, limit: 2 }).catch(() => [])
    const ragContext = formatRagContext(ragResults)
    const augmentedAgent1Prompt = ragContext ? buildRagAugmentedPrompt(PROFILE_ANALYZER_PROMPT, ragContext) : PROFILE_ANALYZER_PROMPT

    // Agent 1 + exercise fetch in parallel
    console.log("[orchestrator:sync] Running Agent 1 + exercise fetch...")
    const [agent1Result, allExercises] = await Promise.all([
      callAgent<ProfileAnalysis>(augmentedAgent1Prompt, agent1UserMessage, profileAnalysisSchema, { model: MODEL_HAIKU, cacheSystemPrompt: true }),
      getExercisesForAI(),
    ])
    tokenUsage.agent1 = agent1Result.tokens_used
    console.log("[orchestrator:sync] Agent 1 complete. Tokens:", agent1Result.tokens_used, "Exercises:", allExercises.length)

    // Save conversation (fire-and-forget)
    const genSessionId = `gen-${log.id}`
    saveConversationBatch([
      { user_id: requestedBy, feature: "program_generation", session_id: genSessionId, role: "user", content: agent1UserMessage, metadata: { step: 1, log_id: log.id, client_id: request.client_id }, tokens_input: null, tokens_output: null, model_used: null },
      { user_id: requestedBy, feature: "program_generation", session_id: genSessionId, role: "assistant", content: JSON.stringify(agent1Result.content), metadata: { step: 1, log_id: log.id, model: MODEL_HAIKU }, tokens_input: null, tokens_output: agent1Result.tokens_used, model_used: MODEL_HAIKU },
    ]).then((saved) => {
      const assistantMsg = saved.find((m: Record<string, unknown>) => m.role === "assistant")
      if (assistantMsg) embedConversationMessage(assistantMsg.id).catch(() => {})
    }).catch(() => {})

    const analysis = agent1Result.content
    const allCompressed = allExercises // already compressed from getExercisesForAI
    const compressed = assessmentContext ? filterByDifficultyScore(allCompressed, assessmentContext.maxDifficultyScore) : allCompressed

    if (request.split_type) analysis.recommended_split = request.split_type as typeof analysis.recommended_split
    if (request.periodization) analysis.recommended_periodization = request.periodization as typeof analysis.recommended_periodization

    // Agent 2
    const agent2UserMessage = `Profile Analysis:\n${JSON.stringify(analysis)}\n\nTraining Parameters:\n- Duration: ${request.duration_weeks} weeks\n- Sessions per week: ${request.sessions_per_week}\n- Session length: ${request.session_minutes ?? 60} minutes\n- Split type: ${analysis.recommended_split}\n- Periodization: ${analysis.recommended_periodization}\n- Goals: ${request.goals.join(", ")}\n${request.additional_instructions ? `- Additional instructions: ${request.additional_instructions}` : ""}`

    console.log("[orchestrator:sync] Running Agent 2 (program architect)...")
    const agent2Result = await callAgent<ProgramSkeleton>(PROGRAM_ARCHITECT_PROMPT, agent2UserMessage, programSkeletonSchema, { maxTokens: 16384, cacheSystemPrompt: true })
    tokenUsage.agent2 = agent2Result.tokens_used
    const skeleton = agent2Result.content
    console.log("[orchestrator:sync] Agent 2 complete. Tokens:", agent2Result.tokens_used)

    saveConversationBatch([
      { user_id: requestedBy, feature: "program_generation", session_id: genSessionId, role: "user", content: agent2UserMessage, metadata: { step: 2, log_id: log.id }, tokens_input: null, tokens_output: null, model_used: null },
      { user_id: requestedBy, feature: "program_generation", session_id: genSessionId, role: "assistant", content: JSON.stringify(agent2Result.content), metadata: { step: 2, log_id: log.id }, tokens_input: null, tokens_output: agent2Result.tokens_used, model_used: MODEL_SONNET },
    ]).then((saved) => {
      const assistantMsg = saved.find((m: Record<string, unknown>) => m.role === "assistant")
      if (assistantMsg) embedConversationMessage(assistantMsg.id).catch(() => {})
    }).catch(() => {})

    // Pre-filter exercises
    const availableEquipment = request.equipment_override ?? profile?.available_equipment ?? []
    const constraintsContext = JSON.stringify({
      exercise_constraints: analysis.exercise_constraints,
      available_equipment: availableEquipment,
      client_difficulty: profile?.experience_level ?? "beginner",
    })

    let filtered: CompressedExercise[]
    try { filtered = await semanticFilterExercises(compressed, skeleton, availableEquipment, analysis) }
    catch { filtered = scoreAndFilterExercises(compressed, skeleton, availableEquipment, analysis) }
    const exerciseLibrary = formatExerciseLibrary(filtered)

    // Agent 3 with validation retry loop
    console.log("[orchestrator:sync] Running Agent 3 with", filtered.length, "exercises...")
    let assignment: ExerciseAssignment | null = null
    let validation: ValidationResult | null = null

    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      let feedbackSection = ""
      if (attempt > 0 && validation !== null) {
        const errorIssues = validation.issues.filter((i) => i.type === "error")
        feedbackSection = `\n\nPREVIOUS ATTEMPT FAILED VALIDATION. Issues to fix:\n${JSON.stringify(errorIssues)}\n\nPlease fix ALL errors and try again.`
      }

      const agent3UserMessage = `Program Skeleton:\n${JSON.stringify(skeleton)}\n\nConstraints:\n${constraintsContext}\n\nExercise Library (${filtered.length} exercises):\n${exerciseLibrary}${feedbackSection}`

      try {
        const agent3Result: AgentCallResult<ExerciseAssignment> = await callAgent<ExerciseAssignment>(EXERCISE_SELECTOR_PROMPT, agent3UserMessage, exerciseAssignmentSchema, { maxTokens: 16384, cacheSystemPrompt: true })
        tokenUsage.agent3 += agent3Result.tokens_used
        assignment = agent3Result.content

        validation = validateProgram(skeleton, assignment, analysis, compressed, availableEquipment, profile?.experience_level ?? "beginner", assessmentContext?.maxDifficultyScore)
        console.log(`[orchestrator:sync] Validation: pass=${validation.pass}, errors=${validation.issues.filter(i => i.type === "error").length}`)

        if (validation.pass || !validation.issues.some((i) => i.type === "error")) break
        retries++
      } catch (agentError) {
        if (attempt === MAX_RETRIES) throw new Error(`Exercise selection failed after ${MAX_RETRIES + 1} attempts: ${agentError instanceof Error ? agentError.message : "Unknown error"}`)
        retries++
      }
    }

    if (!assignment || !validation) throw new Error("Failed to generate exercise assignments")

    // Create program
    const programCategory = deriveProgramCategory(request.goals)
    const programDifficulty = mapDifficulty(profile?.experience_level ?? null)
    const goalsLabel = request.goals.map((g) => g.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase())).join(" & ")
    const splitLabel = skeleton.split_type.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase())

    const program = await createProgram({
      name: request.client_id ? `${clientName}'s ${request.duration_weeks}-Week ${goalsLabel} Program` : `${request.duration_weeks}-Week ${goalsLabel} Program`,
      description: `A ${request.duration_weeks}-week ${splitLabel.toLowerCase()} program designed for ${goalsLabel.toLowerCase()}, training ${request.sessions_per_week}x per week. ${skeleton.notes}`,
      category: [programCategory],
      difficulty: programDifficulty,
      tier: request.tier ?? "premium",
      duration_weeks: request.duration_weeks,
      sessions_per_week: request.sessions_per_week,
      split_type: skeleton.split_type,
      periodization: skeleton.periodization,
      is_public: request.is_public ?? false,
      is_ai_generated: true,
      ai_generation_params: { request, analysis_summary: { split: analysis.recommended_split, periodization: analysis.recommended_periodization, training_age: analysis.training_age_category, constraints_count: analysis.exercise_constraints.length }, validation: { pass: validation.pass, warnings: validation.issues.filter((i) => i.type === "warning").length, errors: validation.issues.filter((i) => i.type === "error").length }, token_usage: tokenUsage },
      is_active: true,
      created_by: requestedBy,
      price_cents: null,
      target_user_id: null,
    })

    // Insert exercises
    const slotLookup = new Map<string, { week_number: number; day_of_week: number; order_index: number }>()
    const slotDetailsLookup = new Map<string, { sets: number; reps: string; rest_seconds: number; rpe_target: number | null; tempo: string | null; group_tag: string | null; technique: ExerciseSlot["technique"] }>()

    for (const week of skeleton.weeks) {
      for (const day of week.days) {
        day.slots.forEach((slot, idx) => {
          slotLookup.set(slot.slot_id, { week_number: week.week_number, day_of_week: day.day_of_week, order_index: idx })
          slotDetailsLookup.set(slot.slot_id, { sets: slot.sets, reps: slot.reps, rest_seconds: slot.rest_seconds, rpe_target: slot.rpe_target, tempo: slot.tempo, group_tag: slot.group_tag, technique: slot.technique ?? "straight_set" })
        })
      }
    }

    await Promise.all(assignment.assignments.map((assigned) => {
      const location = slotLookup.get(assigned.slot_id)
      const details = slotDetailsLookup.get(assigned.slot_id)
      if (!location || !details) return Promise.resolve(null)
      return addExerciseToProgram({
        program_id: program.id, exercise_id: assigned.exercise_id,
        day_of_week: location.day_of_week, week_number: location.week_number,
        order_index: location.order_index, sets: details.sets, reps: details.reps,
        duration_seconds: null, rest_seconds: details.rest_seconds, notes: assigned.notes,
        rpe_target: details.rpe_target, intensity_pct: null, tempo: details.tempo,
        group_tag: details.group_tag, technique: details.technique ?? "straight_set",
      })
    }))

    // Auto-assign
    if (request.client_id) {
      try {
        await createAssignment({
          program_id: program.id, user_id: request.client_id,
          assigned_by: requestedBy, start_date: new Date().toISOString().split("T")[0],
          end_date: null, status: "active", notes: "Auto-assigned from AI program generation",
          current_week: 1, total_weeks: program.duration_weeks ?? null,
        })
      } catch (e) { console.error("[orchestrator:sync] Failed to auto-assign:", e) }
    }

    // Update log
    const durationMs = Date.now() - startTime
    tokenUsage.total = tokenUsage.agent1 + tokenUsage.agent2 + tokenUsage.agent3

    await updateGenerationLog(log.id, {
      program_id: program.id, status: "completed",
      tokens_used: tokenUsage.total, duration_ms: durationMs,
      completed_at: new Date().toISOString(),
      output_summary: { program_id: program.id, program_name: program.name, exercises_assigned: assignment.assignments.length, validation_pass: validation.pass, warnings: validation.issues.filter((i) => i.type === "warning").length, retries },
    })

    return { program_id: program.id, validation, token_usage: tokenUsage, duration_ms: durationMs, retries }
  } catch (error) {
    const durationMs = Date.now() - startTime
    tokenUsage.total = tokenUsage.agent1 + tokenUsage.agent2 + tokenUsage.agent3
    const errorMessage = error instanceof Error ? error.message : "Unknown error during program generation"
    console.error("[orchestrator:sync] PIPELINE FAILED:", errorMessage)

    await updateGenerationLog(log.id, {
      status: "failed", error_message: errorMessage,
      tokens_used: tokenUsage.total, duration_ms: durationMs,
    }).catch((e) => console.error("Failed to update generation log:", e))

    throw error
  }
}
